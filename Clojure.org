#+TITLE: Using Clojure

This file contains manual how to live with Clojure.

* Linter
=clj-kondo=

* Documentation

- [[https://clojuredocs.org][Clojuredocs.org]] :: Reference with community-provided examples
- [[https://clojuredocs.org/quickref][Quick reference]] :: One page with all functions and their docstrings
- [[http://clojure-doc.org/articles/content.html][clojure-docs.org]] :: Community-developed guides (tutorials, cookbooks, manuals)
- [[http://clojure.github.io/clojure/index.html][API overview]] :: official api overview, the same as in Dash/DevDocs docset

*Cheatsheets*

- [[https://jafingerhut.github.io/cheatsheet/clojuredocs/cheatsheet-tiptip-cdocs-summary.html][Clojure cheatsheet with tooltips]] :: liks go to Clojuredocs
- [[https://clojure.org/api/cheatsheet][Official cheatsheet]] :: links go to Clojuredocs

*Blogs*

- https://betweentwoparens.com/

* Generate documentation for your project

- [[https://github.com/weavejester/codox][Dynadoc]] ::
- [[https://github.com/weavejester/codox][Codox]] :: A tool for generating API documentation from Clojure or
  ClojureScript source code.

* Notes on talks/books/posts
** What Sucks about Clojure and Why You'll Love It Anyway - Chas Emerick
https://www.youtube.com/watch?v=wXgdxCFDjD0

Objectives:
- Present a fair critique of Clojure from a pragmatic user's perspective
- What will you with you knew now?

* Starting a new application

- [[https://github.com/seancorfield/clj-new][clj-new]] :: Generate new projects based on clj, Boot, or Leiningen Templates


*ClojureScript*

* Style guide

** Docstrings

* Working with files

** Write file

=clojure.java.io= is your friend here.

#+begin_src clojure
(require '[clojure.java.io :as io])

(defn write-file [name content]
  (with-open [w (io/writer name)]
    (.write w content)))
#+end_src

** Read file

=slurp= to read all as a string from a file.

#+begin_src clojure
(require '[clojure.java.io :as io])

(defn read-file [name]
  (slurp (io/reader name)))

(read-file "sqd_offers.env")
#+end_src

* Working with JSON

[[http://dakrone.github.io/cheshire/][Cheshire documentation]].

* Namespaces

#+begin_src clojure
; switch to namespace
(in-ns 'fh.hotel-explorer.main)
#+end_src

* Destructuring

#+begin_src clojure
((fn [{a :a b :b :as full}]
   [a b full]) {:a 1 :b 2 :c 3})
;; => [1 2 {:c 3, :b 2, :a 1}]
#+end_src

* Convert data formats

- jet :: convert between JSON, END and Transit

* Portal - tool for exploring data structures in web-interface
https://github.com/djblue/portal

To Start Babashka with Portal dependency:
#+begin_src shell
bb -cp $(clj -Spath -Sdeps '{:deps {djblue/portal {:mvn/version "0.5.1"}}}') --nrepl-server 1666
#+end_src

* Dependencies

Create =deps.edn= file like this

#+begin_src clojure
{:deps {djblue/portal {:mvn/version "0.5.1"}
        com.google.guava/guava {:mvn/version "29.0-jre"}}}
#+end_src

and from the folder with the file run

#+begin_src shell
clj -Spath
#+end_src

it will load specified dependencies and output CLASSPATH.

* REPL/nREPL

#+begin_src shell
clj -R:nREPL -m nrepl.cmdline --port 1700
#+end_src

To change namespace:

#+begin_src clojure
(in-ns 'main)
#+end_src

* Babashka

#+begin_src bash
bb -cp (clj -Spath) --nrepl-server 1666
#+end_src

** Use AWS with Babashka

https://github.com/tzzh/pod-tzzh-aws

* Benchmarking
<2020-11-14 Sat>
Found this snippet in ClojureDocs on =into=

#+begin_src clojure
;; Let's benchmark, using Criterium (https://github.com/hugoduncan/criterium)
(require '[criterium.core :refer [quick-bench]])
(quick-bench (into [-1 -2] xform (range 1000000)))
;   Execution time lower quantile : 54.368948 ms ( 2.5%)
;   Execution time upper quantile : 55.976303 ms (97.5%)
#+end_src

* Getting help within Emacs

- =C-c C-d C-d=, =cider-doc=, within CIDER buffer - open documentation
- Then within *cider-doc* buffer - =cider-clojuredocs= - open ClojureDocs examples

* Reading "Clojure Design Patterns"
<2021-03-07 Sun>

Things I learn while reading beatiful "[[http://mishadoff.com/blog/clojure-design-patterns/][Clojure Design Patterns]]" post.

- [[https://clojuredocs.org/clojure.core/juxt][juxt]] :: Takes a set of functions and returns a fn that is the
  juxtaposition of those fns. The returned fn takes a variable number
  of args, and returns a vector containing the result of applying each
  fn to the args (left-to-right).

  =((juxt a b c) x) => [(a x) (b x) (c x)]=

- [[https://clojuredocs.org/clojure.core/complement][complement]] :: =(complement f)= Takes a fn f and returns a fn that
  takes the same arguments as f, has the same effects, if any, and
  returns the opposite truth value.


- [[https://clojuredocs.org/clojure.core/defmulti][defmulti]] :: pattern matching on steroids


- [[https://clojuredocs.org/clojure.core/add-watch][add-watch]] :: add watcher to an agent/atom/var/ref reference.


- prepost-map? :: optional ={:pre [] :post []}= map in =defn= that
  goes after params vector and makes assertions on entering or exiting
  from the function


Conclusions:

- *Command* is just a function
- *Strategy* is just a function passed to another function.
- if a language support multiple dispatch, you donâ€™t need *Visitor* pattern
- if your function has side-effects, memoization is bad idea

* Macro vs composition vs anonymous function vs regular call

#+begin_src clojure
(let [a (fn [x] (+ x 3))
      b (fn [y] (* y 2))]
  {:lambda (#(a (b %)) 4)
   :comp ((comp a b) 4)
   :call (a (b 4))
   :macro (-> 4 b a)})
#+end_src

* Dealing with time using Java

#+begin_src clojure
(.format
 (java.time.ZonedDateTime/now (java.time.ZoneId/of "Europe/Dublin"))
 (java.time.format.DateTimeFormatter/ISO_INSTANT))


(.format
 (java.time.ZonedDateTime/ofInstant
  (java.time.Instant/ofEpochMilli (System/currentTimeMillis))
  (java.time.ZoneId/of "Europe/Dublin"))
 (java.time.format.DateTimeFormatter/ISO_INSTANT))


(.format
 (java.time.LocalDateTime/now)
 (java.time.format.DateTimeFormatter/ofPattern "yyyy-MM-dd HH:mm:ss"))


;; (.parse date-formatter (format-datetime))
;;
;; (string->timestamp-seconds (format-datetime))
;; => 1622823919

(def date-formatter
  (java.time.format.DateTimeFormatter/ofPattern "yyyy-MM-dd'T'HH:mm:ssZ"))


(defn timestamp-seconds->string [ts]
  (.format
   (java.time.ZonedDateTime/ofInstant
    (java.time.Instant/ofEpochSecond ts)
    (java.time.ZoneId/of "Europe/Dublin"))
   date-formatter))

(defn string->timestamp-seconds
  "Parse string in ISO format and returns unix timestamp in seconds."
  [s]
  (.getLong
   (java.time.ZonedDateTime/parse s date-formatter)
   (java.time.temporal.ChronoField/INSTANT_SECONDS)))

;; (string->timestamp-seconds "2021-06-04T17:25:39+0100")
#+end_src

* Parsing command line arguments
<2021-06-25 Fri>

Links:

- https://vlaaad.github.io/tools-cli-in-10-lines-of-code

* Writing main function to invoke as an app
<2021-06-25 Fri>

#+begin_src clojure
(defn -main [& opts]
  (let [f #(try
             (let [form (read-string %)]
               (cond
                 (qualified-symbol? form) @(requiring-resolve form)
                 (symbol? form) @((ns-publics (symbol (namespace `-main))) form)
                 :else form))
             (catch Exception _ %))
        [f & args] (map f opts)]
    (some-> (apply f args) prn)))

(defn rooms [& {:as params}]
  (poll rooms-context params))
#+end_src


#+begin_src sh
clj -m fh.sapi.main fh.sapi.raa/rooms :hotel-id 1137651 :currency RUB
#+end_src
